#define _CRT_SECURE_NO_WARNINGS
#include "chip_8.h" // Подключаем заголовочный файл класса chip8


// Данные для шрифтсета CHIP-8 (каждый символ 5 байт)
unsigned char chip8_fontset[80] = {
    0xF0, 0x90, 0x90, 0x90, 0xF0,  // 0: Представление цифры 0 в виде спрайта (далее - аналогично)
    0x20, 0x60, 0x20, 0x20, 0x70,  // 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0,  // 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0,  // 3
    0x90, 0x90, 0xF0, 0x10, 0x10,  // 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0,  // 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0,  // 6
    0xF0, 0x10, 0x20, 0x40, 0x40,  // 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0,  // 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0,  // 9
    0xF0, 0x90, 0xF0, 0x90, 0x90,  // A
    0xE0, 0x90, 0xE0, 0x90, 0xE0,  // B
    0xF0, 0x80, 0x80, 0x80, 0xF0,  // C
    0xE0, 0x90, 0x90, 0x90, 0xE0,  // D
    0xF0, 0x80, 0xF0, 0x80, 0xF0,  // E
    0xF0, 0x80, 0xF0, 0x80, 0x80   // F
};

chip8::chip8() {  // Конструктор класса chip8: вызывается при создании объекта chip8
    // Пустое тело конструктора: пока не требуется никакой дополнительной инициализации
}

chip8::~chip8() {  // Деструктор класса chip8: вызывается при уничтожении объекта chip8
    // Пустое тело деструктора: пока не требуется никакой дополнительной очистки
}

void chip8::init() {  // Инициализация состояния эмулятора
    pc = 0x200;        // Устанавливаем программный счетчик (PC) на 0x200: начало ROM в памяти
    opcode = 0;        // Сбрасываем текущий опкод
    I = 0;             // Сбрасываем индексный регистр (I)
    sp = 0;            // Сбрасываем указатель стека (SP)

    // Очищаем дисплей, устанавливая все пиксели в 0 (выключено)
    for (int i = 0; i < 2048; ++i) gfx[i] = 0;

    // Очищаем стек, записывая 0 во все ячейки стека
    for (int i = 0; i < 16; ++i) stack[i] = 0;

    // Очищаем все регистры V0-VF и сбрасываем состояние клавиш
    for (int i = 0; i < 16; ++i) key[i] = V[i] = 0;

    // Очищаем всю память, записывая 0 во все ячейки памяти
    for (int i = 0; i < 4096; ++i) memory[i] = 0;

    // Загружаем шрифтсет в память, начиная с адреса 0x000
    for (int i = 0; i < 80; ++i) memory[i] = chip8_fontset[i];

    // Сбрасываем таймеры задержки и звука
    delay_timer = 0;
    sound_timer = 0;

    // Устанавливаем флаг перерисовки экрана в true, чтобы при первом запуске экран был сразу отрисован
    drawFlag = true;

    srand(time(NULL));  // Инициализируем генератор случайных чисел на основе текущего времени

    lastCycleTime = 0; // Инициализируем время последнего цикла для контроля скорости эмуляции
}

void chip8::emulateCycle() {  // Эмуляция одного цикла процессора CHIP-8
    // Извлекаем опкод из памяти: объединяем два байта в один 16-битный опкод
    opcode = memory[pc] << 8 | memory[pc + 1];

    // Обрабатываем опкод: определяем тип операции и выполняем соответствующие действия
    switch (opcode & 0xF000) {  // Маскируем первые 4 бита (старший полубайт) для определения типа опкода
    case 0x0000:  // Опкоды, начинающиеся с 0x0 (разные операции)
        switch (opcode & 0x000F) {  // Маскируем последние 4 бита (младший полубайт) для уточнения операции
        case 0x0000:  // 0x00E0: Очистка экрана
            for (int i = 0; i < 2048; ++i) gfx[i] = 0x0;  // Устанавливаем все пиксели в 0 (очистка дисплея)
            drawFlag = true;  // Устанавливаем флаг перерисовки
            pc += 2;          // Переходим к следующему опкоду (увеличиваем PC на 2 байта)
            break;

        case 0x000E:  // 0x00EE: Возврат из подпрограммы
            --sp;           // Уменьшаем указатель стека (SP), чтобы указать на предыдущий адрес возврата
            pc = stack[sp];  // Извлекаем адрес возврата из стека и присваиваем его PC
            pc += 2;  // Переходим к следующему опкоду (увеличиваем PC на 2 байта)
            break;

        default:  // Неизвестный опкод, начинающийся с 0x0
            printf("Unknown opcode [0x0000]: 0x%X\n", opcode);  // Выводим сообщение об ошибке
        }
        break;

    case 0x1000:  // 0x1NNN: Переход по адресу NNN
        pc = opcode & 0x0FFF;  // Устанавливаем PC на адрес NNN (маскируем последние 12 бит)
        break;

    case 0x2000:  // 0x2NNN: Вызов подпрограммы по адресу NNN
        stack[sp] = pc;          // Сохраняем текущий адрес (PC) в стеке
        ++sp;                    // Увеличиваем указатель стека (SP)
        pc = opcode & 0x0FFF;  // Устанавливаем PC на адрес NNN (маскируем последние 12 бит)
        break;

    case 0x3000:  // 0x3XNN: Пропустить следующую инструкцию, если V[X] == NN
        if (V[(opcode & 0x0F00) >> 8] == (opcode & 0x00FF))  // Сравниваем регистр V[X] с NN
            pc += 4;  // Если равны, пропускаем следующую инструкцию (увеличиваем PC на 4)
        else
            pc += 2;  // Иначе, переходим к следующей инструкции (увеличиваем PC на 2)
        break;

    case 0x4000:  // 0x4XNN: Пропустить следующую инструкцию, если V[X] != NN
        if (V[(opcode & 0x0F00) >> 8] != (opcode & 0x00FF))  // Сравниваем регистр V[X] с NN
            pc += 4;  // Если не равны, пропускаем следующую инструкцию (увеличиваем PC на 4)
        else
            pc += 2;  // Иначе, переходим к следующей инструкции (увеличиваем PC на 2)
        break;

    case 0x5000:  // 0x5XY0: Пропустить следующую инструкцию, если V[X] == V[Y]
        if (V[(opcode & 0x0F00) >> 8] == V[(opcode & 0x00F0) >> 4])  // Сравниваем регистр V[X] с регистром V[Y]
            pc += 4;  // Если равны, пропускаем следующую инструкцию (увеличиваем PC на 4)
        else
            pc += 2;  // Иначе, переходим к следующей инструкции (увеличиваем PC на 2)
        break;

    case 0x6000:  // 0x6XNN: V[X] = NN
        V[(opcode & 0x0F00) >> 8] = opcode & 0x00FF;  // Устанавливаем значение регистра V[X] равным NN
        pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
        break;

    case 0x7000:  // 0x7XNN: V[X] += NN
        V[(opcode & 0x0F00) >> 8] += opcode & 0x00FF;  // Добавляем значение NN к регистру V[X]
        pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
        break;

    case 0x8000:  // Опкоды, начинающиеся с 0x8 (разные операции с регистрами)
        switch (opcode & 0x000F) {  // Маскируем последние 4 бита для уточнения операции
        case 0x0000:  // 0x8XY0: V[X] = V[Y]
            V[(opcode & 0x0F00) >> 8] = V[(opcode & 0x00F0) >> 4];  // Присваиваем регистру V[X] значение регистра V[Y]
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0001:  // 0x8XY1: V[X] = V[X] | V[Y] (побитовое ИЛИ)
            V[(opcode & 0x0F00) >> 8] |= V[(opcode & 0x00F0) >> 4];  // Выполняем побитовое ИЛИ между V[X] и V[Y] и сохраняем результат в V[X]
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0002:  // 0x8XY2: V[X] = V[X] & V[Y] (побитовое И)
            V[(opcode & 0x0F00) >> 8] &= V[(opcode & 0x00F0) >> 4];  // Выполняем побитовое И между V[X] и V[Y] и сохраняем результат в V[X]
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0003:  // 0x8XY3: V[X] = V[X] ^ V[Y] (побитовое исключающее ИЛИ, XOR)
            V[(opcode & 0x0F00) >> 8] ^= V[(opcode & 0x00F0) >> 4];  // Выполняем побитовое XOR между V[X] и V[Y] и сохраняем результат в V[X]
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0004:  // 0x8XY4: V[X] += V[Y], V[F] = carry (сложение с переносом)
            if (V[(opcode & 0x00F0) >> 4] > (0xFF - V[(opcode & 0x0F00) >> 8]))  // Проверяем, будет ли перенос
                V[0xF] = 1;  // Если будет, устанавливаем V[F] в 1
            else
                V[0xF] = 0;  // Иначе, устанавливаем V[F] в 0
            V[(opcode & 0x0F00) >> 8] += V[(opcode & 0x00F0) >> 4];  // Складываем V[X] и V[Y] и сохраняем результат в V[X]
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0005:  // 0x8XY5: V[X] -= V[Y], V[F] = borrow (вычитание с займом)
            if (V[(opcode & 0x00F0) >> 4] > V[(opcode & 0x0F00) >> 8])  // Проверяем, будет ли заем
                V[0xF] = 0;  // Если будет, устанавливаем V[F] в 0
            else
                V[0xF] = 1;  // Иначе, устанавливаем V[F] в 1
            V[(opcode & 0x0F00) >> 8] -= V[(opcode & 0x00F0) >> 4];  // Вычитаем V[Y] из V[X] и сохраняем результат в V[X]
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0006:  // 0x8XY6: V[X] >>= 1, V[F] = LSB (сдвиг вправо)
            V[0xF] = V[(opcode & 0x0F00) >> 8] & 0x1;  // Сохраняем младший бит V[X] в V[F]
            V[(opcode & 0x0F00) >> 8] >>= 1;  // Сдвигаем V[X] вправо на 1 бит
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0007:  // 0x8XY7: V[X] = V[Y] - V[X], V[F] = borrow (вычитание с займом, обратный порядок)
            if (V[(opcode & 0x0F00) >> 8] > V[(opcode & 0x00F0) >> 4])  // Проверяем, будет ли заем
                V[0xF] = 0;  // Если будет, устанавливаем V[F] в 0
            else
                V[0xF] = 1;  // Иначе, устанавливаем V[F] в 1
            V[(opcode & 0x0F00) >> 8] = V[(opcode & 0x00F0) >> 4] - V[(opcode & 0x0F00) >> 8];  // Вычитаем V[X] из V[Y] и сохраняем результат в V[X]
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x000E:  // 0x8XYE: V[X] <<= 1, V[F] = MSB (сдвиг влево)
            V[0xF] = V[(opcode & 0x0F00) >> 8] >> 7;  // Сохраняем старший бит V[X] в V[F]
            V[(opcode & 0x0F00) >> 8] <<= 1;  // Сдвигаем V[X] влево на 1 бит
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        default:  // Неизвестный опкод, начинающийся с 0x8
            printf("Unknown opcode [0x8000]: 0x%X\n", opcode);  // Выводим сообщение об ошибке
        }
        break;

    case 0x9000:  // 0x9XY0: Пропустить следующую инструкцию, если V[X] != V[Y]
        if (V[(opcode & 0x0F00) >> 8] != V[(opcode & 0x00F0) >> 4])  // Сравниваем регистр V[X] с регистром V[Y]
            pc += 4;  // Если не равны, пропускаем следующую инструкцию (увеличиваем PC на 4)
        else
            pc += 2;  // Иначе, переходим к следующей инструкции (увеличиваем PC на 2)
        break;

    case 0xA000:  // 0xANNN: I = NNN (устанавливаем значение индексного регистра)
        I = opcode & 0x0FFF;  // Присваиваем регистру I значение NNN
        pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
        break;

    case 0xB000:  // 0xBNNN: PC = NNN + V[0] (переход по адресу NNN + V[0])
        pc = (opcode & 0x0FFF) + V[0];  // Устанавливаем PC на значение NNN + V[0]
        break;

    case 0xC000:  // 0xCXNN: V[X] = rand() & NN (случайное число И NN)
        V[(opcode & 0x0F00) >> 8] = (rand() % 0xFF) & (opcode & 0x00FF);  // Генерируем случайное число от 0 до 255, выполняем побитовое И с NN и сохраняем результат в V[X]
        pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
        break;

    case 0xD000:  // 0xDXYN: Рисование спрайта
    {
        unsigned short x = V[(opcode & 0x0F00) >> 8];  // Получаем координату X из регистра V[X]
        unsigned short y = V[(opcode & 0x00F0) >> 4];  // Получаем координату Y из регистра V[Y]
        unsigned short height = opcode & 0x000F;  // Получаем высоту спрайта из последних 4 бит опкода
        unsigned short pixel;  // Переменная для хранения байта спрайта

        V[0xF] = 0;  // Сбрасываем флаг коллизии (V[F] = 0)

        for (int yline = 0; yline < height; yline++) {  // Цикл по строкам спрайта
            pixel = memory[I + yline];  // Считываем байт спрайта из памяти
            for (int xline = 0; xline < 8; xline++) {  // Цикл по битам в байте спрайта
                if ((pixel & (0x80 >> xline)) != 0) {  // Проверяем, установлен ли бит (равен ли он 1)
                    if (gfx[(x + xline + ((y + yline) * 64))] == 1) {  // Проверяем, установлен ли пиксель на экране
                        V[0xF] = 1;  // Если установлен, устанавливаем флаг коллизии (V[F] = 1)
                    }
                    gfx[x + xline + ((y + yline) * 64)] ^= 1;  // Инвертируем пиксель на экране (XOR)
                }
            }
        }

        drawFlag = true;  // Устанавливаем флаг перерисовки
        pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
    }
    break;

    case 0xE000:  // Опкоды, начинающиеся с 0xE (операции с клавиатурой)
        switch (opcode & 0x00FF) {  // Маскируем последние 8 бит для уточнения операции
        case 0x009E:  // 0xEX9E: Пропустить следующую инструкцию, если нажата клавиша V[X]
            if (key[V[(opcode & 0x0F00) >> 8]] != 0)  // Проверяем, нажата ли клавиша, соответствующая значению в V[X]
                pc += 4;  // Если нажата, пропускаем следующую инструкцию (увеличиваем PC на 4)
            else
                pc += 2;  // Иначе, переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x00A1:  // 0xEXA1: Пропустить следующую инструкцию, если НЕ нажата клавиша V[X]
            if (key[V[(opcode & 0x0F00) >> 8]] == 0)  // Проверяем, НЕ нажата ли клавиша, соответствующая значению в V[X]
                pc += 4;  // Если не нажата, пропускаем следующую инструкцию (увеличиваем PC на 4)
            else
                pc += 2;  // Иначе, переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        default:  // Неизвестный опкод, начинающийся с 0xE
            printf("Unknown opcode [0xE000]: 0x%X\n", opcode);  // Выводим сообщение об ошибке
        }
        break;

    case 0xF000:  // Опкоды, начинающиеся с 0xF (разные операции)
        switch (opcode & 0x00FF) {  // Маскируем последние 8 бит для уточнения операции
        case 0x0007:  // 0xFX07: V[X] = delay_timer (V[X] присваиваем значение таймера задержки)
            V[(opcode & 0x0F00) >> 8] = delay_timer;  // Присваиваем V[X] значение delay_timer
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x000A:  // 0xFX0A: Ожидание нажатия клавиши и сохранение значения в V[X]
        {
            bool keyPress = false;  // Флаг, показывающий, что клавиша была нажата

            for (int i = 0; i < 16; ++i) {  // Проходим по всем клавишам
                if (key[i] != 0) {  // Если какая-то клавиша нажата
                    V[(opcode & 0x0F00) >> 8] = i;  // Сохраняем значение клавиши в V[X]
                    keyPress = true;  // Устанавливаем флаг
                    break;  // Выходим из цикла
                }
            }

            if (!keyPress) return;  // Если клавиша не нажата, выходим из функции (ждем нажатия в следующем цикле)

            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
        }
        break;

        case 0x0015:  // 0xFX15: delay_timer = V[X] (таймер задержки = V[X])
            delay_timer = V[(opcode & 0x0F00) >> 8];  // Присваиваем таймеру задержки значение V[X]
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0018:  // 0xFX18: sound_timer = V[X] (звуковой таймер = V[X])
            sound_timer = V[(opcode & 0x0F00) >> 8];  // Присваиваем звуковому таймеру значение V[X]
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x001E:  // 0xFX1E: I += V[X] (I = I + V[X])
            if (I + V[(opcode & 0x0F00) >> 8] > 0xFFF)  // Проверяем, не будет ли переполнение
                V[0xF] = 1;  // Если будет, V[F] = 1
            else
                V[0xF] = 0;  // Иначе, V[F] = 0
            I += V[(opcode & 0x0F00) >> 8];  // Добавляем V[X] к I
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0029:  // 0xFX29: I = sprite_location[V[X]] (I = адрес спрайта для символа V[X])
            I = V[(opcode & 0x0F00) >> 8] * 0x5;  // Устанавливаем I на адрес спрайта для символа V[X] (каждый спрайт 5 байт)
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0033:  // 0xFX33: Сохранение BCD-представления V[X] в памяти по адресу I
            memory[I] = V[(opcode & 0x0F00) >> 8] / 100;  // Сотни
            memory[I + 1] = (V[(opcode & 0x0F00) >> 8] / 10) % 10;  // Десятки
            memory[I + 2] = (V[(opcode & 0x0F00) >> 8] % 100) % 10;  // Единицы
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0055:  // 0xFX55: Сохранение регистров V0 до VX в памяти, начиная с адреса I
            for (int i = 0; i <= ((opcode & 0x0F00) >> 8); ++i)
                memory[I + i] = V[i];  // Копируем значения регистров V0-VX в память

            I += ((opcode & 0x0F00) >> 8) + 1;  // Увеличиваем I на X + 1 (как в оригинальном интерпретаторе)
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        case 0x0065:  // 0xFX65: Заполнение регистров V0 до VX из памяти, начиная с адреса I
            for (int i = 0; i <= ((opcode & 0x0F00) >> 8); ++i)
                V[i] = memory[I + i];  // Заполняем значения регистров V0-VX из памяти

            I += ((opcode & 0x0F00) >> 8) + 1;  // Увеличиваем I на X + 1 (как в оригинальном интерпретаторе)
            pc += 2;  // Переходим к следующей инструкции (увеличиваем PC на 2)
            break;

        default:  // Неизвестный опкод, начинающийся с 0xF
            printf("Unknown opcode [0xF000]: 0x%X\n", opcode);  // Выводим сообщение об ошибке
        }
        break;

    default:  // Неизвестный опкод
        printf("Unknown opcode: 0x%X\n", opcode);  // Выводим сообщение об ошибке
    }

    // Обновляем таймеры
    if (delay_timer > 0) --delay_timer;  // Уменьшаем значение таймера задержки, если он больше 0

    if (sound_timer > 0) {  // Если звуковой таймер больше 0
        if (sound_timer == 1) printf("BEEP!\n");  // Издаем звук "BEEP", когда таймер равен 1
        --sound_timer;  // Уменьшаем значение звукового таймера
    }
}

void chip8::debugRender() {  // Функция отладочного вывода на экран
    // Выводим содержимое дисплея в консоль (для отладки)
    for (int y = 0; y < 32; ++y) {  // Цикл по строкам
        for (int x = 0; x < 64; ++x) {  // Цикл по столбцам
            if (gfx[(y * 64) + x] == 0)  // Если пиксель выключен
                printf("O");  // Выводим "O"
            else
                printf(" ");  // Иначе (если пиксель включен), выводим пробел
        }
        printf("\n");  // Переходим на новую строку
    }
    printf("\n");
}

bool chip8::loadApplication(const char* filename) {  // Загрузка ROM-файла (игры)
    init();  // Вызываем init для сброса эмулятора

    printf("Loading: %s\n", filename);  // Выводим сообщение о загрузке файла

    // Открываем файл
    FILE* pFile = fopen(filename, "rb");  // Открываем файл в бинарном режиме
    if (pFile == NULL) {  // Если не удалось открыть файл
        fputs("File error", stderr);  // Выводим сообщение об ошибке в stderr
        return false;  // Возвращаем false (ошибка)
    }

    // Проверяем размер файла
    fseek(pFile, 0, SEEK_END);  // Перемещаем указатель в конец файла
    long lSize = ftell(pFile);   // Получаем размер файла
    rewind(pFile);  // Возвращаем указатель в начало файла
    printf("Filesize: %d\n", (int)lSize);  // Выводим размер файла

    // Выделяем память для хранения всего файла
    char* buffer = (char*)malloc(sizeof(char) * lSize);  // Выделяем память размером с файл
    if (buffer == NULL) {  // Если не удалось выделить память
        fputs("Memory error", stderr);  // Выводим сообщение об ошибке в stderr
        fclose(pFile); // Закрываем файл, чтобы избежать утечек ресурсов
        return false;  // Возвращаем false (ошибка)
    }

    // Копируем файл в буфер
    size_t result = fread(buffer, 1, lSize, pFile);  // Читаем содержимое файла в буфер
    if (result != lSize) {  // Если не удалось прочитать весь файл
        fputs("Reading error", stderr);  // Выводим сообщение об ошибке в stderr
        fclose(pFile); // Закрываем файл, чтобы избежать утечек ресурсов
        free(buffer); // Освобождаем выделенную память
        return false;  // Возвращаем false (ошибка)
    }

    // Копируем буфер в память Chip8
    if ((4096 - 512) > lSize) {  // Проверяем, поместится ли ROM в память (начиная с адреса 0x200)
        for (int i = 0; i < lSize; ++i)
            memory[i + 512] = buffer[i];  // Копируем содержимое буфера в память Chip8
    }
    else
        printf("Error: ROM too big for memory");  // Если ROM слишком большой, выводим сообщение об ошибке

    // Закрываем файл и освобождаем буфер
    fclose(pFile);  // Закрываем файл
    free(buffer);  // Освобождаем выделенную память

    return true;  // Возвращаем true (успех)
}